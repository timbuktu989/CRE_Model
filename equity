import uuid
from typing import List

class Partner:
    """A class representing a partner in the equity structure."""

    def __init__(self, name: str, equity_contribution: float, preferred_return: float, partner_id: str = None):
        self.name = name
        self.equity_contribution = equity_contribution
        self.preferred_return = preferred_return
        self.partner_id = partner_id if partner_id is not None else str(uuid.uuid4())
        self.profits_received = 0

    def receive_profits(self, amount: float):
        self.profits_received += amount

    def __str__(self):
        return f"{self.name} (Equity Contribution: {self.equity_contribution}, Preferred Return: {self.preferred_return * 100}%)"

    def __repr__(self):
        return f"Partner(name={self.name!r}, equity_contribution={self.equity_contribution}, preferred_return={self.preferred_return}, partner_id={self.partner_id!r})"

class Waterfall:
    """A class that handles the distribution of profits among partners."""

    def __init__(self, tiers: List[float], partners: List[Partner], tier_type: str = "fixed"):
        self.tiers = tiers
        self.partners = partners
        self.tier_type = tier_type
        self.total_equity = sum(partner.equity_contribution for partner in partners)

    def distribute_profits(self, total_profit: float):
        """Distribute the total_profit among partners according to the waterfall structure."""
        remaining_profit = total_profit

        # Distribute preferred return
        for partner in self.partners:
            preferred_amount = partner.equity_contribution * partner.preferred_return
            distribution = min(remaining_profit, preferred_amount)
            partner.receive_profits(distribution)
            remaining_profit -= distribution

        # Distribute remaining profits based on tiers
        for tier in self.tiers:
            tier_amount = self.total_equity * tier
            if remaining_profit <= tier_amount:
                self._distribute_profits_pro_rata(remaining_profit)
                break
            else:
                self._distribute_profits_pro_rata(tier_amount)
                remaining_profit -= tier_amount

    def _distribute_profits_pro_rata(self, amount: float):
        """Distribute the specified amount of profit among partners according to their share ratios."""
        if self.tier_type == "fixed":
            share_ratio = [partner.equity_contribution / self.total_equity for partner in self.partners]
        elif self.tier_type == "equity":
            share_ratio = [partner.equity_contribution for partner in self.partners]
        else:
            raise ValueError("Invalid tier_type")

        for partner, share in zip(self.partners, share_ratio):
            distribution = share * amount
            partner.receive_profits(distribution)

    def profit_distribution_report(self) -> str:
        """Return a formatted string representing the profit distribution for each partner."""
        report = []
        for partner in self.partners:
            report.append(f"{partner}: Profits Received: {partner.profits_received}")
        return "\n".join(report)

    def reset_profit_distribution(self):
        """Reset the profit distribution for each partner."""
        for partner in self.partners:
            partner.profits_received = 0
